# 可維護性

軟體的大部分開銷並不在最初的開發階段，而是在持續的維護階段，包括
- 修復漏洞
- 保持系統正常執行
- 調查失效
- 適配新的平臺
- 為新的場景進行修改
- 償還技術債
- 新增新的功能

許多從事軟體系統行業的人不喜歡維護所謂的 遺留（legacy） 系統,因為涉及
- 涉及修復其他人的錯誤
- 和過時的平臺打交道
- 系統被迫使用於一些份外工作

很難給出一個通用的建議來和它們打交道

應該以這樣一種方式來設計軟體：在設計之初就儘量考慮儘可能減少維護期間的痛苦，從而避免自己的軟體系統變成遺留系統。
為此，將特別關注軟體系統的三個設計原則：
- 可操作性（Operability）
  - 便於運維團隊保持系統平穩執行。
- 簡單性（Simplicity）
  - 從系統中消除儘可能多的 複雜度（complexity），使新工程師也能輕鬆理解系統（注意這和使用者介面的簡單性不一樣）。
- 可演化性（evolvability）
  - 使工程師在未來能輕鬆地對系統進行更改，當需求變化時為新應用場景做適配。也稱為 可擴充套件性（extensibility）、可修改性（modifiability） 或 可塑性（plasticity）。

> 實現這些目標也沒有簡單的解決方案。不過我們會試著想象具有可操作性，簡單性和可演化性的系統會是什麼樣子。

## 可操作性
：人生苦短，關愛運維
> “良好的運維經常可以繞開垃圾（或不完整）軟體的侷限性，而再好的軟體攤上垃圾運維也沒法可靠執行”。
> 儘管運維的某些方面可以，而且應該是自動化的，但在最初建立正確運作的自動化機制仍然取決於人。

運維團隊對於保持軟體系統順利執行至關重要。一個優秀運維團隊的典型職責如下（或者更多）：
- 監控系統的執行狀況，並在服務狀態不佳時快速恢復服務。
- 跟蹤問題的原因，例如系統故障或效能下降。
- 及時更新軟體和平臺，比如安全補丁。
- 瞭解系統間的相互作用，以便在異常變更造成損失前進行規避。
- 預測未來的問題，並在問題出現之前加以解決（例如，容量規劃）。
- 建立部署、配置、管理方面的良好實踐，編寫相應工具。
- 執行複雜的維護任務，例如將應用程式從一個平臺遷移到另一個平臺。
- 當配置變更時，維持系統的安全性。
- 定義工作流程，使運維操作可預測，並保持生產環境穩定。
- 鐵打的營盤流水的兵，維持組織對系統的瞭解。

良好的可操作性意味著更輕鬆的日常工作，進而運維團隊能專注於高價值的事情。資料系統可以透過各種方式使日常任務更輕鬆：
- 透過良好的監控，提供對系統內部狀態和執行時行為的 可見性（visibility）。
- 為自動化提供良好支援，將系統與標準化工具相整合。
- 避免依賴單臺機器（在整個系統繼續不間斷執行的情況下允許機器停機維護）。
- 提供良好的文件和易於理解的操作模型（“如果做 X，會發生 Y”）。
- 提供良好的預設行為，但需要時也允許管理員自由覆蓋預設值。
- 有條件時進行自我修復，但需要時也允許管理員手動控制系統狀態。
- 行為可預測，最大限度減少意外。

## 簡單性
：管理複雜度

小型軟體專案可以使用簡單討喜的、富表現力的程式碼，但隨著專案越來越大，程式碼往往變得非常複雜，難以理解。->爛泥潭（a big ball of mud）

脈絡:
> 複雜度會造成問題 -> 降低複雜度 -> 簡化系統 -> 消除額外複雜度 -> 抽象

複雜度（complexity） 可能的症狀，
- 狀態空間激增
- 模組間緊密耦合
- 糾結的依賴關係
- 不一致的命名和術語
- 解決效能問題的 Hack
- 需要繞開的特例

複雜度高將導致:
- 維護困難
- 預算和時間安排超支
- 由變更所導致引入錯誤的風險增加
- 開發人員難以理解系統
  - 隱藏的假設、無意的後果和意外的互動易被忽略

降低複雜度能提高軟體的可維護性

簡化系統意味著(不一定減少功能):
- 消除額外的（accidental） 的複雜度

額外複雜度：由具體實現中湧現，而非（從使用者視角看，系統所解決的）問題本身固有的複雜度。

消除額外複雜度的方式：

### 抽象（abstraction）
- 將大量實現細節隱藏在一個乾淨，簡單易懂的外觀中
- 比起重複造輪子，重用抽象
  - 更有效率
  - 助於開發高質量的軟體
  - 抽象元件的質量改進將使所有使用它的應用受益

抽象範例
- 高階程式語言
  - 隱藏了
    - 機器碼
    - CPU 暫存器
    - 系統呼叫
- SQL
  - 隱藏了
    - 複雜的磁碟 / 記憶體資料結構
    - 來自其他客戶端的併發請求
    - 崩潰後的不一致性

> 抽象還是有使用底層元件(不過不是直接使用->因此不必去考慮這些實現細節)

抽象可以幫助我們將系統的複雜度控制在可管理的水平
不過，找到好的抽象是非常困難的。
在分散式系統領域雖然有許多好的演算法，但我們並不清楚它們應該打包成什麼樣抽象。

因此要關注那些允許我們將大型系統的部分提取為定義明確的、可重用的元件的優秀抽象。

## 可演化性
系統的需求永遠不變，基本是不可能的。
更可能的情況是，它們處於常態的變化中，
- 瞭解了新的事實
- 出現意想不到的應用場景
- 業務優先順序發生變化
- 使用者要求新功能
- 新平臺取代舊平臺
- 法律或監管要求發生變化
- 系統增長迫使架構變化

### 較小規模的敏捷技術：
敏捷（agile） 工作模式為適應變化提供了一個框架,敏捷社群還開發了對在頻繁變化的環境中開發軟體很有幫助的技術工具和模式
- 測試驅動開發（TDD, test-driven development）
- 重構（refactoring）

### 較大規模的敏捷技術：
例如，為了將裝配主頁時間線的方法從方法 1 變為方法 2，你會如何 “重構” 推特的架構 ？

