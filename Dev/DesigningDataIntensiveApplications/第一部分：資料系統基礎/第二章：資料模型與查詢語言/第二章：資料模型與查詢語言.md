
> 語言的邊界就是思想的邊界。

資料模型可能是軟體開發中最重要的部分了，因為它們的影響如此深遠：不僅僅影響著軟體的編寫方式，而且影響著我們的 解題思路。

多數應用使用層層疊加的資料模型構建。對於每層資料模型的關鍵問題是：它是如何用低一層資料模型來 表示 的？例如：
- 作為一名應用開發人員，你觀察現實世界（裡面有人員、組織、貨物、行為、資金流向、感測器等），並採用物件或資料結構，以及操控那些資料結構的 API 來進行建模。那些結構通常是特定於應用程式的。
- 當要儲存那些資料結構時，你可以利用通用資料模型來表示它們，如 JSON 或 XML 文件、關係資料庫中的表或圖模型。
- 資料庫軟體的工程師選定如何以記憶體、磁碟或網路上的位元組來表示 JSON / XML/ 關係 / 圖資料。這類表示形式使資料有可能以各種方式來查詢，搜尋，操縱和處理。
- 在更低的層次上，硬體工程師已經想出了使用電流、光脈衝、磁場或者其他東西來表示位元組的方法。

一個複雜的應用程式可能會有更多的中間層次，比如基於 API 的 API，不過基本思想仍然是一樣的：每個層都透過提供一個明確的資料模型來隱藏更低層次中的複雜性。
抽象允許不同的人群有效地協作（例如資料庫廠商的工程師和使用資料庫的應用程式開發人員）。

資料模型種類繁多，每個資料模型都帶有如何使用的設想。有些用法很容易，有些則不支援如此；有些操作執行很快，有些則表現很差；有些資料轉換非常自然，有些則很麻煩。

掌握一個數據模型需要花費很多精力（想想關係資料建模有多少本書）。即便只使用一個數據模型，不用操心其內部工作機制，構建軟體也是非常困難的。然而，因為資料模型對上層軟體的功能（能做什麼，不能做什麼）有著至深的影響，所以選擇一個適合的資料模型是非常重要的。

## 關係模型與文件模型
現在最著名的資料模型可能是 SQL。
資料被組織成
- 關係（SQL中稱作表）
- 其中每個關係是元組（SQL 中稱作 行) 的無序集合

隨著電腦越來越強大和互聯，它們開始用於日益多樣化的目的。關係資料庫非常成功地被推廣到業務資料處理的原始範圍之外更為廣泛的用例上。你今天在網上看到的大部分內容依舊是由關係資料庫來提供支援，無論是線上釋出，討論，社交網路，電子商務，遊戲，軟體即服務生產力應用程式等等內容。

### NoSQL
（Not Only SQL）

採用 NoSQL 資料庫的背後有幾個驅動因素，其中包括：
- 需要比關係資料庫更好的可伸縮性，包括非常大的資料集或非常高的寫入吞吐量
- 相比商業資料庫產品，免費和開源軟體更受偏愛
- 關係模型不能很好地支援一些特殊的查詢操作
- 受挫於關係模型的限制性，渴望一種更具多動態性與表現力的資料模型

不同的應用程式有不同的需求，一個用例的最佳技術選擇可能不同於另一個用例的最佳技術選擇。
關係資料庫似乎可能會繼續與各種非關係資料庫一起使用 - 這種想法有時也被稱為 混合持久化（polyglot persistence）

### 物件關係不匹配
目前大多數應用程式開發都使用面向物件的程式語言來開發，這導致了對 SQL 資料模型的普遍批評：
- 如果資料儲存在關係表中，那麼需要一個笨拙的轉換層，處於應用程式程式碼中的物件和表，行，列的資料庫模型之間。模型之間的不連貫有時被稱為 阻抗不匹配（impedance mismatch）。

像 ActiveRecord 和 Hibernate 這樣的 物件關係對映（ORM object-relational mapping） 框架可以減少這個轉換層所需的樣板程式碼的數量，但是它們不能完全隱藏這兩個模型之間的差異。

對於一個像簡歷這樣自包含文件的資料結構而言，JSON 表示是非常合適的：請參閱 例 2-1。JSON 比 XML 更簡單。面向文件的資料庫（如 MongoDB ，RethinkDB ，CouchDB和 Espresso）支援這種資料模型。

JSON 模型減少了應用程式程式碼和儲存層之間的阻抗不匹配。
不過，JSON 作為資料編碼格式也存在問題。缺乏一個模式往往被認為是一個優勢

JSON 比 RDB 的多表模式具有更好的 區域性性（locality）。
如果在關係型示例中獲取簡介，那需要執行多個查詢（透過 user_id 查詢每個表），或者在 User 表與其下屬表之間混亂地執行多路連線。
而在 JSON 表示中，所有相關資訊都在同一個地方，一個查詢就足夠了。

### 多對一和多對多的關係
如果使用者介面用一個自由文字欄位來輸入區域和行業，那麼將他們儲存為純文字字串是合理的。另一方式是給出地理區域和行業的標準化的列表，並讓使用者從下拉列表或自動填充器中進行選擇，其優勢如下：

各個簡介之間樣式和拼寫統一
- 避免歧義（例如，如果有幾個同名的城市）
- 易於更新 —— 名稱只儲存在一個地方，如果需要更改（例如，由於政治事件而改變城市名稱），很容易進行全面更新。
- 本地化支援 —— 當網站翻譯成其他語言時，標準化的列表可以被本地化，使得地區和行業可以使用使用者的語言來顯示
- 更好的搜尋 —— 例如，搜尋華盛頓州的慈善家就會匹配這份簡介，因為地區列表可以編碼記錄西雅圖在華盛頓這一事實（從 “Greater Seattle Area” 這個字串中看不出來）

儲存 ID 還是文字字串，這是個副本（duplication） 問題。當使用 ID 時，對人類有意義的資訊（比如單詞：Philanthropy）只儲存在一處，所有引用它的地方使用 ID（ID 只在資料庫中有意義）。
當直接儲存文字時，對人類有意義的資訊會複製在每處使用記錄中。

ID 的好處
- ID 對人類沒有任何意義，因而永遠不需要改變
- ID 可以保持不變，即使它標識的資訊發生變化
- 任何對人類有意義的東西都可能需要在將來某個時候改變 —— 如果這些資訊被複制，所有的冗餘副本都需要更新。這會導致寫入開銷，也存在不一致的風險（一些副本被更新了，還有些副本沒有被更新）
- 去除此類重複是資料庫 規範化（normalization） 的關鍵思想。
- 關於關係模型的文獻區分了幾種不同的規範形式，但這些區別幾乎沒有實際意義。一個經驗法則是，如果重複儲存了可以儲存在一個地方的值，則模式就不是規範化（normalized） 的。

不幸的是，對這些資料進行規範化需要多對一的關係（許多人生活在一個特定的地區，許多人在一個特定的行業工作），這與文件模型不太吻合。在關係資料庫中，透過 ID 來引用其他表中的行是正常的，因為連線很容易。
在文件資料庫中，一對多樹結構沒有必要用連線，對連線的支援通常很弱。

即便應用程式的最初版本適合無連線的文件模型，隨著功能新增到應用程式中，資料會變得更加互聯。例如，考慮一下對簡歷例子進行的一些修改：
- 組織和學校作為實體
  - 在前面的描述中，organization（使用者工作的公司）和 school_name（他們學習的地方）只是字串。也許他們應該是對實體的引用呢？然後，每個組織、學校或大學都可以擁有自己的網頁（標識，新聞提要等）。每個簡歷可以連結到它所提到的組織和學校，並且包括他們的圖示和其他資訊（請參閱 圖 2-3，來自 LinkedIn 的一個例子）。
- 推薦
  - 假設你想新增一個新的功能：一個使用者可以為另一個使用者寫一個推薦。在使用者的簡歷上顯示推薦，並附上推薦使用者的姓名和照片。如果推薦人更新他們的照片，那他們寫的任何推薦都需要顯示新的照片。因此，推薦應該擁有作者個人簡介的引用。

### 文件資料庫是否在重蹈覆轍？
- 關係模型（relational model，它變成了 SQL，並統治了世界）
  - 將所有的資料放在光天化日之下
  - 一個 關係（表） 只是一個 元組（行） 的集合
  - 外來鍵約束允許對修改進行限制，但對於關係模型這並不是必選項。即使有約束，外來鍵連線在查詢時執行，而在 CODASYL 中，連線在插入時高效完成。
  - 關係資料庫的查詢最佳化器是複雜的，已耗費了多年的研究和開發精力。
    - 關係模型的一個關鍵洞察是：只需構建一次查詢最佳化器，隨後使用該資料庫的所有應用程式都可以從中受益。如果沒有查詢最佳化器的話，那麼為特定查詢手動編寫訪問路徑比編寫通用最佳化器更容易 —— 不過從長期看通用解決方案更好。
- 網狀模型（network model，最初很受關注，但最終變得冷門）
  -  CODASYL 模型
  -  每條記錄可能有多個父節點
  -  記錄之間的連結
     -  指標
  - 訪問記錄方法
    - 跟隨從根記錄起沿這些鏈路所形成的路徑。這被稱為 訪問路徑（access path）
    - 訪問路徑類似遍歷連結串列

### 關係型資料庫 vs 文件資料庫
- 容錯屬性
- 處理併發性
- 資料模型
  - 關係模型
    - 連線
      - 對關聯提供更好的支援
  - 文件
    - 區域性

### 哪種資料模型更有助於簡化應用程式碼？
應用程式中的資料具有類似文件的結構（即，一對多關係樹，通常一次性載入整個樹
那麼使用文件模型可能是一個好主意。
- 將類似文件的結構分解成多個表（positions、education 和 contact_info）的關係技術可能導致繁瑣的模式和不必要的複雜的應用程式程式碼。
- 文件模型有侷限性：例如，不能直接引用文件中的巢狀的專案，而是需要說 “使用者 251 的位置列表中的第二項”（很像層次模型中的訪問路徑）。
  - 但只要檔案巢狀不太深，這通常不是問題。
  - 文件資料庫對連線支援度不好

高度關聯的資料->圖形模型

### 文件模型中的模式靈活性
文件資料庫有時稱為 無模式（schemaless），但這具有誤導性，因為讀取資料的程式碼通常假定某種結構 —— 即存在隱式模式，但不由資料庫強制執行
讀時模式（即 schema-on-read，資料的結構是隱含的，只有在資料被讀取時才被解釋），相應的是 寫時模式（即 schema-on-write，傳統的關係資料庫方法中，模式明確，且資料庫確保所有的資料都符合其模式）。

- 讀時模式
  - 類似於程式語言中的動態（執行時）型別檢查
- 寫時模式
  - 類似於靜態（編譯時）型別檢查。

> 資料庫中模式的強制性是一個具有爭議的話題，一般來說沒有正確或錯誤的答案

在應用程式想要改變其資料格式的情況下，這些方法之間的區別尤其明顯。
例如，假設你把每個使用者的全名儲存在一個欄位中，而現在想分別儲存名字和姓氏。
文件資料庫中，只需開始寫入具有新欄位的新文件，並在應用程式中使用程式碼來處理讀取舊文件的情況。

在 “靜態型別” 資料庫模式中，通常會執行以下 遷移（migration）
模式變更的速度很慢，而且要求停運。它的這種壞名譽並不是完全應得的：大多數關係資料庫系統可在幾毫秒內執行 ALTER TABLE 語句。MySQL 是一個值得注意的例外，它執行 ALTER TABLE 時會複製整個表，這可能意味著在更改一個大型表時會花費幾分鐘甚至幾個小時的停機時間，儘管存在各種工具來解決這個限制

大型表上執行 UPDATE 語句在任何資料庫上都可能會很慢，因為每一行都需要重寫。
要是不可接受的話，應用程式可以將 first_name 設定為預設值 NULL，並在讀取時再填充，就像使用文件資料庫一樣。

當由於某種原因（例如，資料是異構的）集合中的專案並不都具有相同的結構時，讀時模式更具優勢。例如，如果：
- 存在許多不同型別的物件，將每種型別的物件放在自己的表中是不現實的。
- 資料的結構由外部系統決定。你無法控制外部系統且它隨時可能變化。

上述情況下，模式的壞處遠大於它的幫助，無模式文件可能是一個更加自然的資料模型。但是，要是所有記錄都具有相同的結構，那麼模式是記錄並強制這種結構的有效機制。

### 查詢的資料區域性性
文件通常以單個連續字串形式進行儲存，編碼為 JSON、XML 或其二進位制變體（如 MongoDB 的 BSON）。如果應用程式經常需要訪問整個文件（例如，將其渲染至網頁），那麼儲存區域性性會帶來效能優勢。如果將資料分割到多個表中（如 圖 2-1 所示），則需要進行多次索引查詢才能將其全部檢索出來，這可能需要更多的磁碟查詢並花費更多的時間。

區域性性僅僅適用於同時需要文件絕大部分內容的情況。
資料庫通常需要載入整個文件，即使只訪問其中的一小部分，這對於大型文件來說是很浪費的。更新文件時，通常需要整個重寫。只有不改變文件大小的修改才可以容易地原地執行。
通常建議保持相對小的文件，並避免增加文件大小的寫入。這些效能限制大大減少了文件資料庫的實用場景。

為了區域性性而分組集合相關資料的想法並不侷限於文件模型。例如，Google 的 Spanner 資料庫在關係資料模型中提供了同樣的區域性性屬性，允許模式宣告一個表的行應該交錯（巢狀）在父表內。
Oracle 類似地允許使用一個稱為 多表索引叢集表（multi-table index cluster tables） 的類似特性。Bigtable 資料模型（用於 Cassandra 和 HBase）中的 列族（column-family） 概念與管理區域性性的目的類似。

### 文件和關係資料庫的融合
關係模型和文件模型的混合是未來資料庫一條很好的路線。
Codd 對關係模型的原始描述實際上允許在關係模式中與 JSON 文件非常相似。
他稱之為 非簡單域（nonsimple domains）。
這個想法是，一行中的值不一定是一個像數字或字串一樣的原始資料型別，也可以是一個巢狀的關係（表），因此可以把一個任意巢狀的樹結構作為一個值，就像之後新增到 SQL 中的 JSON 或 XML 支援。

## 資料查詢語言
在宣告式查詢語言（如 SQL 或關係代數）中，你只需指定以下幾點 (而不是如何實現這一目標)
- 所需資料的模式
- 結果必須符合哪些條件
- 如何將資料轉換（例如，排序，分組和集合）但。

資料庫系統的查詢最佳化器決定使用哪些索引和哪些連線方法，以及以何種順序執行查詢的各個部分。

### 宣告式查詢語言
- 比命令式 API 更加簡潔和容易。
- 隱藏了資料庫引擎的實現細節
- 資料庫系統可以在無需對查詢做任何更改的情況下進行效能提升

例如，在本節開頭所示的命令程式碼中，動物列表以特定順序出現。如果資料庫想要在後臺回收未使用的磁碟空間，則可能需要移動記錄，這會改變動物出現的順序。資料庫能否安全地執行，而不會中斷查詢？

SQL 示例不確保任何特定的順序，因此不在意順序是否改變。但是如果查詢用命令式的程式碼來寫的話，那麼資料庫就永遠不可能確定程式碼是否依賴於排序。SQL 相當有限的功能性為資料庫提供了更多自動最佳化的空間。

宣告式語言往往適合並行執行。
現在，CPU 的速度透過核心（core）的增加變得更快，而不是以比以前更高的時鐘速度執行。
命令程式碼很難在多個核心和多個機器之間並行化，因為它指定了指令必須以特定順序執行。宣告式語言更具有並行執行的潛力，因為它們僅指定結果的模式，而不指定用於確定結果的演算法。在適當情況下，資料庫可以自由使用查詢語言的並行實現。

### Web 上的宣告式查詢

宣告式查詢語言的優勢不僅限於資料庫

宣告式查詢語言的優勢不僅限於資料庫。
為了說明這一點，讓我們在一個完全不同的環境中比較宣告式和命令式方法：一個 Web 瀏覽器。

### MapReduce查詢
MapReduce 是一個由 Google 推廣的程式設計模型，用於在多臺機器上批次處理大規模的資料。
一些 NoSQL 資料儲存支援有限形式的 MapReduce，作為在多個文件中執行只讀查詢的機制。
- MongoDB
- CouchDB

MapReduce 
- 不是一個宣告式的查詢語言
- 不是一個完全命令式的查詢 API
- 而是處於兩者之間

查詢的邏輯用程式碼片段來表示，這些程式碼片段會被處理框架重複性呼叫。
它基於 map（也稱為 collect）和 reduce（也稱為 fold 或 inject）函式，兩個函式存在於許多函數語言程式設計語言中。

map 和 reduce 函式在功能上有所限制：
- 它們必須是 純 函式
  - 它們只使用傳遞給它們的資料作為輸入
  - 不能執行額外的資料庫查詢
  - 不能有任何副作用
  - 允許資料庫以任何順序執行任何功能
  - 在失敗時重新執行它們

map 和 reduce 函式功能
- 解析字串
- 呼叫庫函式
- 執行計算

聚合管道語言的表現力與（前述 PostgreSQL 例子的）SQL 子集相當，但是它使用基於 JSON 的語法而不是 SQL 那種接近英文句式的語法；這種差異也許只是口味問題。這個故事的寓意是：NoSQL 系統可能會意外發現自己只是重新發明了一套經過喬裝改扮的 SQL。

## 圖資料模型

多對多關係是不同資料模型之間具有區別性的重要特徵。如果你的應用程式大多數的關係是一對多關係（樹狀結構化資料），或者大多數記錄之間不存在關係，那麼使用文件模型是合適的。
多對多關係在資料中常見->將資料建模為圖形

圖由兩種物件組成：
- 物件
  - 頂點:vertices，也稱為 節點，即 nodes
  - 實體:entities
- 關係，即 relationships
  - 邊:edges
  - 弧:arcs

例子:
- 社交圖譜
- 網路圖譜
- 公路或鐵路網路

有幾種不同但相關的方法用來構建和查詢圖表中的資料。
- 屬性圖模型（由 Neo4j，Titan 和 InfiniteGraph 實現）
- 三元組儲存（triple-store）模型（由 Datomic，AllegroGraph 等實現）
 

圖的三種宣告式查詢語言：
- Cypher
- SPARQL
- Datalog

圖形查詢語言Gremlin
圖形處理框架Pregel

## 屬性圖
屬性圖模型中，每個頂點（vertex）包括：

唯一的識別符號
一組出邊（outgoing edges）
一組入邊（ingoing edges）
一組屬性（鍵值對）
每條邊（edge）包括：

唯一識別符號
邊的起點（尾部頂點，即 tail vertex）
邊的終點（頭部頂點，即 head vertex）
描述兩個頂點之間關係型別的標籤
一組屬性（鍵值對）

圖儲存看作由兩個關係表組成：一個儲存頂點，另一個儲存邊

關於這個模型的一些重要方面是：
- 任何頂點都可以有一條邊連線到任何其他頂點。沒有模式限制哪種事物可不可以關聯。
- 給定任何頂點，可以高效地找到它的入邊和出邊，從而遍歷圖，即沿著一系列頂點的路徑前後移動
- 透過對不同型別的關係使用不同的標籤，可以在一個圖中儲存幾種不同的資訊，同時仍然保持一個清晰的資料模型。

圖在可演化性方面是富有優勢的：當你嚮應用程式新增功能時，可以輕鬆擴充套件圖以適應程式資料結構的變化。

### Cypher 查詢語言
Cypher 是屬性圖的宣告式查詢語言
通常對於宣告式查詢語言來說，在編寫查詢語句時，不需要指定執行細節：查詢最佳化程式會自動選擇預測效率最高的策略，因此你可以專注於編寫應用程式的其他部分。

### 三元組儲存和 SPARQL
三元組儲存模式大體上與屬性圖模型相同，用不同的詞來描述相同的想法。
三元組儲存有很多現成的工具和語言，這些工具和語言對於構建應用程式的工具箱可能是寶貴的補充。

三元組儲存中，所有資訊都以非常簡單的三部分表示形式儲存（主語，謂語，賓語）。
- 三元組 (吉姆, 喜歡, 香蕉) 中，吉姆 是主語，喜歡 是謂語（動詞），香蕉 是物件。

三元組的主語相當於圖中的一個頂點。而賓語是下面兩者之一：

- 原始資料型別中的值
  - 例如
    - 字串
    - 數字
    - 三元組的謂語和賓語相當於主語頂點上的屬性的鍵和值。例如，(lucy, age, 33) 就像屬性 {“age”：33} 的頂點 lucy。
- 圖中的另一個頂點
  - 謂語是圖中的一條邊
  - 主語是其尾部頂點
  - 而賓語是其頭部頂點
  - 例如
    - 在 (lucy, marriedTo, alain) 中主語和賓語 lucy 和 alain 都是頂點，並且謂語 marriedTo 是連線他們的邊的標籤。

#### 語義網
如果你深入瞭解關於三元組儲存的資訊，可能會陷入關於語義網的討論漩渦中。三元組儲存模型其實是完全獨立於語義網存在的，例如，Datomic作為一種三元組儲存資料庫，從未被用於語義網中。

語義網是一個簡單且合理的想法：網站已經將資訊釋出為文字和圖片供人類閱讀，為什麼不將資訊作為機器可讀的資料也釋出給計算機呢？
（基於三元組模型的）資源描述框架（RDF），被用作不同網站以統一的格式釋出資料的一種機制，允許來自不同網站的資料自動合併成 一個數據網路 —— 成為一種網際網路範圍內的 “通用語義網資料庫”。

語義網雖然沒有紅起來專案還是擁有很多優秀的成果。即使你沒有興趣在語義網上釋出 RDF 資料，三元組這種模型也是一種好的應用程式內部資料模型。

##### RDF 資料模型

###### SPARQL 查詢語言
SPARQL 是一種用於三元組儲存的面向 RDF 資料模型的查詢語言【43】（它是 SPARQL 協議和 RDF 查詢語言的縮寫，發音為 “sparkle”）。SPARQL 早於 Cypher，並且由於 Cypher 的模式匹配借鑑於 SPARQL，這使得它們看起來非常相似【37】。

### 基礎：Datalog
實踐中，Datalog 在有限的幾個資料系統中使用：例如，它是 Datomic 【40】的查詢語言，Cascalog 【47】是一種用於查詢 Hadoop 大資料集的 Datalog 實現

Datalog 的資料模型類似於三元組模式，但進行了一點泛化。把三元組寫成 謂語（主語，賓語），而不是寫三元語（主語，謂語，賓語）
相對於本章討論的其他查詢語言，我們需要採取不同的思維方式來思考 Datalog 方法，但這是一種非常強大的方法，因為規則可以在不同的查詢中進行組合和重用。雖然對於簡單的一次性查詢，顯得不太方便，但是它可以更好地處理資料很複雜的情況。

## 圖形資料庫與網狀模型相比較
乍一看，CODASYL 的網狀模型看起來與圖模型相似。CODASYL 是否是圖形資料庫的第二個變種？
- 在 CODASYL 中，資料庫有一個模式，用於指定哪種記錄型別可以巢狀在其他記錄型別中。在圖形資料庫中，不存在這樣的限制：任何頂點都可以具有到其他任何頂點的邊。這為應用程式適應不斷變化的需求提供了更大的靈活性。
- 在 CODASYL 中，達到特定記錄的唯一方法是遍歷其中的一個訪問路徑。在圖形資料庫中，可以透過其唯一 ID 直接引用任何頂點，也可以使用索引來查詢具有特定值的頂點。
- 在 CODASYL 中，記錄的子專案是一個有序集合，所以資料庫必須去管理它們的次序（這會影響儲存佈局），並且應用程式在插入新記錄到資料庫時必須關注新記錄在這些集合中的位置。在圖形資料庫中，頂點和邊是無序的（只能在查詢時對結果進行排序）。
- 在 CODASYL 中，所有查詢都是命令式的，難以編寫，並且很容易因架構變化而受到破壞。在圖形資料庫中，你可以在命令式程式碼中手寫遍歷過程，但大多數圖形資料庫都支援高階宣告式查詢，如 Cypher 或 SPARQL。


## 小結
資料最開始被表示為一棵大樹（層次資料模型），但是這不利於表示多對多的關係，所以發明了關係模型來解決這個問題。最近，開發人員發現一些應用程式也不適合採用關係模型。新的非關係型 “NoSQL” 資料儲存分化為兩個主要方向：

- 文件資料庫 主要關注自我包含的資料文件，而且文件之間的關係非常稀少。
- 圖形資料庫 用於相反的場景：任意事物之間都可能存在潛在的關聯。

這三種模型（文件，關係和圖形）在今天都被廣泛使用，並且在各自的領域都發揮很好。
一個模型可以用另一個模型來模擬
> 例如，圖資料可以在關係資料庫中表示 —— 但結果往往是糟糕的。這就是為什麼我們有著針對不同目的的不同系統，而不是一個單一的萬能解決方案。

文件資料庫和圖資料庫有一個共同點,它們通常不會將儲存的資料強制約束為特定模式，這可以使應用程式更容易適應不斷變化的需求。
但是應用程式很可能仍會假定資料具有一定的結構；區別僅在於模式是明確的（寫入時強制）還是隱含的（讀取時處理）。