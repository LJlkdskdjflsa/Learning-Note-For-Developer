> 建立秩序，省卻搜尋

為了讓儲存引擎能在你的工作負載型別上執行良好
-> 大致瞭解儲存引擎在底層究竟做了什麼
-> 要從許多可用的儲存引擎中選擇一個合適的

負載最佳化:(兩者存在巨大差異)
- 針對 事務性
- 針對 分析性

兩大類儲存引擎：
- 日誌結構（log-structured）
- 面向頁面（page-oriented）

## 驅動資料庫的資料結構

高效查詢資料庫中特定鍵的值，我們需要一個數據結構：索引（index）
本章將介紹一系列的索引結構，並在它們之間進行比較。索引背後的大致思想是透過儲存一些額外的元資料作為路標來幫助你找到想要的資料。如果你想以幾種不同的方式搜尋同一份資料，那麼你也許需要在資料的不同部分上建立多個索引。

索引是從主資料衍生的 額外的（additional） 結構。許多資料庫允許新增與刪除索引，這不會影響資料的內容，而只會影響查詢的效能。
維護額外的結構會產生開銷，特別是在寫入時。
任何型別的索引通常都會減慢寫入速度，因為每次寫入資料時都需要更新索引。

### 雜湊索引
鍵值儲存與在大多數程式語言中可以找到的 字典（dictionary） 型別非常相似，通常字典都是用 雜湊對映（hash map） 或 散列表（hash table） 實現的。
當你想查詢一個值時，使用雜湊對映來查詢資料檔案中的偏移量，尋找（seek） 該位置並讀取該值即可。

![](https://vonng.github.io/ddia/img/fig3-1.png)

到目前為止，我們只是在追加寫入一個檔案 —— 所以如何避免最終用完硬碟空間？一種好的解決方案是，將日誌分為特定大小的段（segment）
當日志增長到特定尺寸時關閉當前段檔案，並開始寫入一個新的段檔案。
然後，我們就可以對這些段進行 壓縮（compaction）。

每個段現在都有自己的記憶體散列表，將鍵對映到檔案偏移量。
為了找到一個鍵的值，我們首先檢查最近的段的雜湊對映；如果鍵不存在，我們就檢查第二個最近的段，依此類推。合併過程將保持段的數量足夠小，所以查詢過程不需要檢查太多的雜湊對映。

要讓這個簡單的想法在實際中能工作會涉及到大量的細節。簡單來說，下面幾點都是實現過程中需要認真考慮的問題：
- 檔案格式
  - CSV 不是日誌的最佳格式。使用二進位制格式更快，更簡單：首先以位元組為單位對字串的長度進行編碼，然後是原始的字串（不需要轉義）。
- 刪除記錄
  - 在資料檔案中追加一個特殊的刪除記錄（邏輯刪除，有時被稱為墓碑，即 tombstone）
  - 當日志段被合併時，合併過程會透過這個墓碑知道要將被刪除鍵的所有歷史值都丟棄掉。
- 崩潰恢復
  - 如果資料庫重新啟動，則記憶體雜湊對映將丟失
  - 可以透過從頭到尾讀取整個段檔案並記錄下來每個鍵的最近值來恢復每個段的雜湊對映。
  - But: 如果段檔案很大，可能需要很長時間，這會使服務的重啟比較痛苦。 
  - Bitcask 透過將每個段的雜湊對映的快照儲存在硬碟上來加速恢復，可以使雜湊對映更快地載入到記憶體中。
- 部分寫入記錄
  - 資料庫隨時可能崩潰，包括在將記錄追加到日誌的過程中
  - Bitcask 檔案包含校驗，允許檢測和忽略日誌中的這些損壞部分。
- 併發控制
  - 由於寫操作是以嚴格的順序追加到日誌中的，所以常見的實現是隻有一個寫入執行緒。
  - 因為資料檔案段是僅追加的或者說是不可變的，所以它們可以被多個執行緒同時讀取。 

> 乍一看，僅追加日誌似乎很浪費：為什麼不直接在檔案裡更新，用新值覆蓋舊值？僅追加的設計之所以是個好的設計，有如下幾個原因：
- 追加和分段合併都是順序寫入操作，通常比隨機寫入快得多，尤其是在磁性機械硬碟上
  - 順序寫入在基於快閃記憶體的固態硬碟（SSD）上也是好的選擇
- 如果段檔案是僅追加的或不可變的，併發和崩潰恢復就很簡單
  - 當一個數據值被更新的時候發生崩潰，你不用擔心檔案裡將會同時包含舊值和新值各自的一部分
- 合併舊段的處理也可以避免資料檔案隨著時間的推移而碎片化的問題

散列表索引也有其侷限性：
- 必須能放進記憶體
  - 如果你有非常多的鍵，那真是倒楣。
  - 原則上可以在硬碟上維護一個雜湊對映，不幸的是硬碟雜湊對映很難表現優秀。
  - 它需要大量的隨機訪問 I/O，而後者耗盡時想要再擴充是很昂貴的，並且需要很煩瑣的邏輯去解決雜湊衝突。
- 範圍查詢效率不高。例如，你無法輕鬆掃描 kitty00000 和 kitty99999 之間的所有鍵 —— 你必須在雜湊對映中單獨查詢每個鍵。

## SSTables製作LSM樹
排序字串表（Sorted String Table）
- 鍵值對的序列按鍵排序
- 每個鍵只在每個合併的段檔案中出現一次（壓縮過程已經保證）

SSTable 的優勢
- 即使檔案大於可用記憶體，合併段的操作仍然是簡單而高效的
- 為了在檔案中找到一個特定的鍵，你不再需要在記憶體中儲存所有鍵的索引
  - 可以順序查找
- 由於讀取請求無論如何都需要掃描所請求範圍內的多個鍵值對，因此可以將這些記錄分組為塊（block），並在將其寫入硬碟之前對其進行壓縮
  - 稀疏記憶體索引中的每個條目都指向壓縮塊的開始處
  - 節省硬碟空間
  - 減少對 I/O 頻寬的使用

### 構建和維護SSTables
到目前為止還不錯，但是如何讓你的資料能夠預先排好序呢？畢竟我們接收到的寫入請求可能以任何順序發生。

這些資料結構，你可以按任何順序插入鍵，並按排序順序讀取它們。
- 紅黑樹
- AVL 樹

可以讓我們的儲存引擎以如下方式工作：
- 有新寫入時，將其新增到記憶體中的平衡樹資料結構（例如紅黑樹）。這個記憶體樹有時被稱為 記憶體表（memtable）。
- 當記憶體表 大於某個閾值（通常為幾兆位元組）時，將其作為 SSTable 檔案寫入硬碟。這可以高效地完成，因為樹已經維護了按鍵排序的鍵值對。新的 SSTable 檔案將成為資料庫中最新的段。當該 SSTable 被寫入硬碟時，新的寫入可以在一個新的記憶體表例項上繼續進行。
- 收到讀取請求時，首先嘗試在記憶體表中找到對應的鍵，如果沒有就在最近的硬碟段中尋找，如果還沒有就在下一個較舊的段中繼續尋找，以此類推。
- 時不時地，在後臺執行一個合併和壓縮過程，以合併段檔案並將已覆蓋或已刪除的值丟棄掉。

> 這個方案效果很好。它只會遇到一個問題：如果資料庫崩潰，則最近的寫入（在記憶體表中，但尚未寫入硬碟）將丟失。為了避免這個問題，我們可以在硬碟上儲存一個單獨的日誌，每個寫入都會立即被追加到這個日誌上，就像在前面的章節中所描述的那樣。這個日誌沒有按排序順序，但這並不重要，因為它的唯一目的是在崩潰後恢復記憶體表。每當記憶體表寫出到 SSTable 時，相應的日誌都可以被丟棄。
>

https://vonng.github.io/ddia/#/zh-tw/ch3?id=%e7%94%a8sstables%e8%a3%bd%e4%bd%9clsm%e6%a8%b9:~:text=%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%A2%AB%E4%B8%9F%E6%A3%84%E3%80%82-,%E7%94%A8SSTables%E8%A3%BD%E4%BD%9CLSM%E6%A8%B9,-%E9%80%99%E8%A3%A1%E6%8F%8F%E8%BF%B0%E7%9A%84
